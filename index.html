<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Windmill</title>
    <style>
        body { 
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        #stats {
            position: absolute;
            top: 60px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
            font-size: 14px;
            min-width: 220px;
        }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 5px;
            color: white;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: inline-block;
            width: 120px;
        }
        .stat-value {
            float: right;
            font-weight: bold;
        }
        .stat-row {
            margin: 5px 0;
            clear: both;
            overflow: hidden;
        }
        #loadingText {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div id="info">Interactive 3D Windmill - Drag to rotate, scroll to zoom</div>
    <div id="loadingText">Loading 3D Model...</div>
    
    <div id="stats">
        <h3 style="margin-top: 0; margin-bottom: 10px;">Energy Production</h3>
        <div class="stat-row">
            <span>Wind Speed:</span>
            <span id="windSpeedStat" class="stat-value">10 mph</span>
        </div>
        <div class="stat-row">
            <span>Blade Diameter:</span>
            <span id="bladeDiameterStat" class="stat-value">50 m</span>
        </div>
        <div class="stat-row">
            <span>Power Output:</span>
            <span id="powerOutputStat" class="stat-value">0 kW</span>
        </div>
        <div class="stat-row">
            <span>Daily Energy:</span>
            <span id="dailyEnergyStat" class="stat-value">0 kWh</span>
        </div>
        <div class="stat-row">
            <span>Efficiency:</span>
            <span id="efficiencyStat" class="stat-value">0%</span>
        </div>
        <div class="stat-row">
            <span>Homes Powered:</span>
            <span id="homesStat" class="stat-value">0</span>
        </div>
    </div>
    
    <div id="controls">
        <div class="slider-container">
            <label for="windSpeed">Wind Speed:</label>
            <input type="range" id="windSpeed" min="0" max="60" value="10" step="1">
            <span id="windSpeedValue">10 mph</span>
        </div>
        <div class="slider-container">
            <label for="cameraHeight">Camera Height:</label>
            <input type="range" id="cameraHeight" min="5" max="100" value="30" step="1">
            <span id="cameraHeightValue">30</span>
        </div>
        <div class="slider-container">
            <label for="rotationSpeed">Rotation Speed:</label>
            <input type="range" id="rotationSpeed" min="0" max="2" value="1" step="0.1">
            <span id="rotationSpeedValue">1x</span>
        </div>
        <div class="slider-container">
            <label for="modelScale">Model Scale:</label>
            <input type="range" id="modelScale" min="1" max="50" value="10" step="1">
            <span id="modelScaleValue">10x</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
<script>
    // Initialize Three.js components
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    
    // Configure renderer
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x87CEEB); // Sky blue
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);
    
    // Custom OrbitControls for camera interaction
    class OrbitControls {
        constructor(camera, domElement) {
            this.camera = camera;
            this.domElement = domElement;
            this.target = new THREE.Vector3(0, 40, 6); // Focus on the hub
            this.enableZoom = true;
            this.enableRotate = true;
            this.rotateSpeed = 1.0;
            this.zoomSpeed = 1.2;
            this.rotateStart = new THREE.Vector2();
            this.rotateEnd = new THREE.Vector2();
            this.rotateDelta = new THREE.Vector2();
            this.isDragging = false;

            this.onMouseDown = this.onMouseDown.bind(this);
            this.onMouseMove = this.onMouseMove.bind(this);
            this.onMouseUp = this.onMouseUp.bind(this);
            this.onMouseWheel = this.onMouseWheel.bind(this);

            this.domElement.addEventListener('mousedown', this.onMouseDown, false);
            this.domElement.addEventListener('wheel', this.onMouseWheel, false);
            this.update();
        }

        onMouseDown(event) {
            if (!this.enableRotate) return;
            event.preventDefault();
            this.isDragging = true;
            this.rotateStart.set(event.clientX, event.clientY);
            document.addEventListener('mousemove', this.onMouseMove, false);
            document.addEventListener('mouseup', this.onMouseUp, false);
        }

        onMouseMove(event) {
            if (!this.isDragging) return;
            event.preventDefault();
            this.rotateEnd.set(event.clientX, event.clientY);
            this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart);
            this.rotateStart.copy(this.rotateEnd);

            const element = this.domElement;
            const rotateLeft = 2 * Math.PI * this.rotateDelta.x / element.clientWidth * this.rotateSpeed;
            const rotateUp = 2 * Math.PI * this.rotateDelta.y / element.clientHeight * this.rotateSpeed;

            const position = this.camera.position.clone().sub(this.target);
            const distance = position.length();
            const theta = Math.atan2(position.x, position.z);
            const phi = Math.acos(Math.min(Math.max(position.y / distance, -1), 1));

            const newTheta = theta + rotateLeft;
            const newPhi = Math.max(0.1, Math.min(Math.PI - 0.1, phi + rotateUp));

            const sinPhiRadius = Math.sin(newPhi) * distance;
            position.x = sinPhiRadius * Math.sin(newTheta);
            position.y = Math.cos(newPhi) * distance;
            position.z = sinPhiRadius * Math.cos(newTheta);

            this.camera.position.copy(this.target).add(position);
            this.update();
        }

        onMouseUp(event) {
            if (!this.enableRotate) return;
            event.preventDefault();
            this.isDragging = false;
            document.removeEventListener('mousemove', this.onMouseMove, false);
            document.removeEventListener('mouseup', this.onMouseUp, false);
        }

        onMouseWheel(event) {
            if (!this.enableZoom) return;
            event.preventDefault();
            const delta = event.deltaY;
            const zoomScale = delta > 0 ? 1.1 : 0.9;
            const direction = new THREE.Vector3().subVectors(this.camera.position, this.target).normalize();
            const distance = this.camera.position.distanceTo(this.target);
            const newDistance = Math.max(5, Math.min(100, distance * zoomScale));
            this.camera.position.copy(this.target).add(direction.multiplyScalar(newDistance));
            this.update();
        }

        update() {
            this.camera.lookAt(this.target);
        }
    }
    
    // Add orbit controls
    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(0, 40, 60);
    controls.update();
    
    // Add lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 100, 20);
    directionalLight.castShadow = true;
    directionalLight.shadow.mapSize.width = 2048;
    directionalLight.shadow.mapSize.height = 2048;
    directionalLight.shadow.camera.near = 0.5;
    directionalLight.shadow.camera.far = 500;
    directionalLight.shadow.camera.left = -100;
    directionalLight.shadow.camera.right = 100;
    directionalLight.shadow.camera.top = 100;
    directionalLight.shadow.camera.bottom = -100;
    scene.add(directionalLight);
    
    // Create ground plane
    const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
    const groundMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x567d46,
        roughness: 0.8,
        metalness: 0.2
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);
    
    // Create windmill group
    const windmill = new THREE.Group();
    scene.add(windmill);
    
    // Variables for animation and configuration
    let windSpeed = 10; // mph
    let rotationSpeed = 0;
    let userRotationMultiplier = 1;
    let bladeLength = 25; // Default blade length for calculations
    let bladeDiameter = bladeLength * 2;
    let windmillModel = null;
    let rotorPart = null;
    let modelScale = 10; // Start with a larger scale

    // Update blade diameter stat
    document.getElementById('bladeDiameterStat').textContent = bladeDiameter + ' m';
    
    // GLTF Loader to load the 3D model
    const loader = new THREE.GLTFLoader();
    const modelUrl = 'your_model_url.glb'; // Replace with your model URL

    // Function to load the 3D model
    function loadModel() {
        loader.load(
            // The model URL - replace this with your actual model URL
            'https://example.com/path/to/windmill.glb',
            
            // onLoad callback - called when the model is loaded
            function(gltf) {
                windmillModel = gltf.scene;
                
                // Add the model to the scene
                windmill.add(windmillModel);
                
                // Set the scale of the model
                windmillModel.scale.set(modelScale, modelScale, modelScale);
                
                // Position the model - may need adjustment based on your model
                windmillModel.position.set(0, 0, 0);
                
                // Cast shadows
                windmillModel.traverse(function(node) {
                    if (node.isMesh) {
                        node.castShadow = true;
                        node.receiveShadow = true;
                    }
                });
                
                // Print the full model hierarchy to the console
                console.log("Full model hierarchy:");
                inspectModelHierarchy(windmillModel);
                
                // Look for parts that might be rotors based on common naming
                const possibleRotors = [];
                windmillModel.traverse(function(node) {
                    const name = node.name.toLowerCase();
                    if (
                        name.includes('rotor') || 
                        name.includes('blade') || 
                        name.includes('propeller') || 
                        name.includes('wind') || 
                        name.includes('turbine') ||
                        name.includes('spin')
                    ) {
                        possibleRotors.push(node);
                        console.log("Potential rotor part found:", node.name, node);
                    }
                });
                
                // If we found potential rotors, use the first one
                if (possibleRotors.length > 0) {
                    rotorPart = possibleRotors[0];
                    console.log("Using this part as rotor:", rotorPart.name);
                } else {
                    console.warn('No rotor parts found automatically. Check console for model hierarchy and update the code manually.');
                }
                
                // Hide loading text
                document.getElementById('loadingText').style.display = 'none';
                
                // Calculate power output based on initial values
                calculatePowerOutput();
            },
            
            // onProgress callback - can be used to show loading progress
            function(xhr) {
                const loadingPercentage = Math.floor((xhr.loaded / xhr.total) * 100);
                document.getElementById('loadingText').textContent = 
                    'Loading 3D Model: ' + loadingPercentage + '%';
            },
            
            // onError callback - called when loading has errors
            function(error) {
                console.error('An error happened while loading the model:', error);
                document.getElementById('loadingText').textContent = 
                    'Error loading model. Please check console for details.';
            }
        );
    }
    
    // Function to calculate power output
    function calculatePowerOutput() {
        const windSpeedMS = windSpeed * 0.44704; // Convert mph to m/s
        const airDensity = 1.225; // kg/m^3
        const sweptArea = Math.PI * Math.pow(bladeDiameter / 2, 2); // Swept area in m^2
        const ratedWindSpeedMS = 12; // Rated wind speed in m/s
        const cutInWindSpeedMS = 3; // Cut-in wind speed in m/s
        const cutOutWindSpeedMS = 25; // Cut-out wind speed in m/s

        // Base efficiency (constant between cut-in and rated speed)
        const baseEfficiency = 0.45; // Based on typical turbine efficiency

        let powerOutput = 0;
        let totalEfficiency = 0;

        // Power calculation based on wind speed regions
        if (windSpeedMS < cutInWindSpeedMS || windSpeedMS >= cutOutWindSpeedMS) {
            powerOutput = 0;
            totalEfficiency = 0;
        } else if (windSpeedMS >= cutInWindSpeedMS && windSpeedMS < ratedWindSpeedMS) {
            const theoreticalPower = 0.5 * airDensity * sweptArea * Math.pow(windSpeedMS, 3);
            totalEfficiency = baseEfficiency;
            powerOutput = theoreticalPower * totalEfficiency / 1000; // Convert to kW
        } else {
            const ratedPower = 0.5 * airDensity * sweptArea * Math.pow(ratedWindSpeedMS, 3);
            totalEfficiency = baseEfficiency;
            powerOutput = ratedPower * totalEfficiency / 1000; // Convert to kW
        }

        // Calculate daily energy and homes powered
        const dailyEnergy = powerOutput * 24; // kWh
        const homeUsagePerDay = 30; // kWh per home per day
        const homesPowered = Math.floor(dailyEnergy / homeUsagePerDay);

        // Update stats display
        document.getElementById('windSpeedStat').textContent = windSpeed + ' mph (' + windSpeedMS.toFixed(1) + ' m/s)';
        document.getElementById('bladeDiameterStat').textContent = bladeDiameter + ' m';
        document.getElementById('powerOutputStat').textContent = powerOutput.toFixed(1) + ' kW';
        document.getElementById('dailyEnergyStat').textContent = dailyEnergy.toFixed(1) + ' kWh';
        document.getElementById('efficiencyStat').textContent = (totalEfficiency * 100).toFixed(1) + '%';
        document.getElementById('homesStat').textContent = homesPowered;

        // Calculate rotation speed (in rad/s) to maintain tip speed ratio
        const tipSpeedRatio = 6;
        const bladeRadius = bladeDiameter / 2;
        if (windSpeedMS < cutInWindSpeedMS || windSpeedMS >= cutOutWindSpeedMS) {
            rotationSpeed = 0;
        } else {
            rotationSpeed = ((tipSpeedRatio * windSpeedMS) / bladeRadius) * userRotationMultiplier;
        }
    }
    
    // Create wind particles
    const particlesCount = 100;
    const particlesGeometry = new THREE.BufferGeometry();
    const particlesMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.5,
        transparent: true,
        opacity: 0.6
    });
    const particlePositions = new Float32Array(particlesCount * 3);
    for (let i = 0; i < particlesCount * 3; i += 3) {
        particlePositions[i] = (Math.random() - 0.5) * 100;
        particlePositions[i + 1] = Math.random() * 50;
        particlePositions[i + 2] = (Math.random() - 0.5) * 100;
    }
    particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
    const particles = new THREE.Points(particlesGeometry, particlesMaterial);
    scene.add(particles);
    
    // UI element references
    const windSpeedSlider = document.getElementById('windSpeed');
    const windSpeedValue = document.getElementById('windSpeedValue');
    const cameraHeightSlider = document.getElementById('cameraHeight');
    const cameraHeightValue = document.getElementById('cameraHeightValue');
    const rotationSpeedSlider = document.getElementById('rotationSpeed');
    const rotationSpeedValue = document.getElementById('rotationSpeedValue');
    const modelScaleSlider = document.getElementById('modelScale');
    const modelScaleValue = document.getElementById('modelScaleValue');
    
    // Event listeners for sliders
    windSpeedSlider.addEventListener('input', function() {
        windSpeed = parseInt(this.value);
        windSpeedValue.textContent = windSpeed + ' mph';
        calculatePowerOutput();
    });
    
    cameraHeightSlider.addEventListener('input', function() {
        const height = parseInt(this.value);
        cameraHeightValue.textContent = height;
        camera.position.y = height;
        controls.update();
    });
    
    rotationSpeedSlider.addEventListener('input', function() {
        userRotationMultiplier = parseFloat(this.value);
        rotationSpeedValue.textContent = userRotationMultiplier.toFixed(1) + 'x';
        calculatePowerOutput();
    });
    
    modelScaleSlider.addEventListener('input', function() {
        modelScale = parseFloat(this.value);
        modelScaleValue.textContent = modelScale.toFixed(1) + 'x';
        if (windmillModel) {
            windmillModel.scale.set(modelScale, modelScale, modelScale);
        }
    });
    
    // Handle window resize
    window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Helper function to inspect model hierarchy and print to console
    function inspectModelHierarchy(object, level = 0) {
        const indent = ' '.repeat(level * 2);
        let typeInfo = object.type;
        
        // Add more specific information based on object type
        if (object.isMesh) typeInfo += ' (Mesh)';
        if (object.isGroup) typeInfo += ' (Group)';
        if (object.isObject3D && !object.isMesh && !object.isGroup) typeInfo += ' (Object3D)';
        
        console.log(`${indent}${object.name || 'unnamed'} [${typeInfo}]`);
        
        // Print additional useful properties
        if (object.isMesh) {
            console.log(`${indent}  - Geometry: ${object.geometry.type}`);
            console.log(`${indent}  - Material: ${object.material.type}`);
        }
        
        // Print position, rotation, scale for all objects
        console.log(`${indent}  - Position: x=${object.position.x.toFixed(2)}, y=${object.position.y.toFixed(2)}, z=${object.position.z.toFixed(2)}`);
        console.log(`${indent}  - Rotation: x=${object.rotation.x.toFixed(2)}, y=${object.rotation.y.toFixed(2)}, z=${object.rotation.z.toFixed(2)}`);
        console.log(`${indent}  - Scale: x=${object.scale.x.toFixed(2)}, y=${object.scale.y.toFixed(2)}, z=${object.scale.z.toFixed(2)}`);
        
        // Recursively process children
        if (object.children && object.children.length > 0) {
            console.log(`${indent}  Children (${object.children.length}):`);
            object.children.forEach(child => inspectModelHierarchy(child, level + 1));
        }
    }
    
    // Load the model
    loadModel();
    
    // Animation loop with frame-rate independence
    let lastTime = performance.now();
    function animate() {
        requestAnimationFrame(animate);
        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) / 1000; // Time in seconds
        
        // Rotate the rotor part if it exists
        if (rotorPart) {
            rotorPart.rotation.z += rotationSpeed * deltaTime;
        }

        // Update particles (adjusted for frame time)
        const positions = particlesGeometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
            positions[i + 2] -= windSpeed * 0.01 * deltaTime * 60; // Adjust speed for consistency
            if (positions[i + 2] < -50) {
                positions[i + 2] = 50;
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = Math.random() * 50;
            }
        }
        particlesGeometry.attributes.position.needsUpdate = true;
        
        renderer.render(scene, camera);
        lastTime = currentTime;
    }
    
    animate();
</script>
</body>
</html>
